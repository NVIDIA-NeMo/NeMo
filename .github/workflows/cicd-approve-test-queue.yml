# Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Approve Test Queue

on:
  schedule:
    - cron: '*/5 * * * *'  # Runs every 5 minutes
  push:
    branches:
      - chtruong/test-approval # Temp for testing only
  workflow_dispatch:  # Allows manual triggering

jobs:
  approve-queue:
    runs-on: ubuntu-latest
    environment: main
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Approve waiting deployments
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
          MAX_CONCURRENCY: ${{ vars.MAX_CONCURRENCY || 1 }}
        run: |
          python - <<EOF
          import os
          import json
          import requests
          from datetime import datetime

          # GitHub API configuration
          GITHUB_TOKEN = os.environ["GITHUB_TOKEN"]
          REPO = os.environ["GITHUB_REPOSITORY"]
          MAX_CONCURRENCY = int(os.environ["MAX_CONCURRENCY"])
          API_BASE = f"https://api.github.com/repos/{REPO}"

          # Headers for GitHub API
          headers = {
              "Authorization": f"token {GITHUB_TOKEN}",
              "Accept": "application/vnd.github.v3+json"
          }

          def make_request(endpoint, method="GET", data=None):
              """Make a request to the GitHub API with error handling."""
              url = f"{API_BASE}/{endpoint}"
              try:
                  if method == "GET":
                      response = requests.get(url, headers=headers)
                  else:
                      response = requests.post(url, headers=headers, json=data)
                  response.raise_for_status()
                  return response.json()
              except requests.exceptions.RequestException as e:
                  print(f"Error making request to {endpoint}: {str(e)}")
                  if hasattr(e.response, 'text'):
                      print(f"Response: {e.response.text}")
                  return None

          # Get current running and queued workflows
          print("Fetching workflow runs...")
          workflow_runs = make_request("actions/runs?status=in_progress,queued")
          if not workflow_runs:
              print("Failed to fetch workflow runs")
              exit(1)

          # Count running and queued workflows
          running_workflows = sum(1 for run in workflow_runs.get("workflow_runs", [])
                                if run["status"] == "in_progress" and run["name"] == "CICD NeMo")
          queued_workflows = sum(1 for run in workflow_runs.get("workflow_runs", [])
                               if run["status"] == "queued" and run["name"] == "CICD NeMo")

          total_workflows = running_workflows + queued_workflows
          print(f"Current running workflows: {running_workflows}")
          print(f"Current queued workflows: {queued_workflows}")
          print(f"Total workflows: {total_workflows}")
          print(f"Max concurrency: {MAX_CONCURRENCY}")

          if total_workflows >= MAX_CONCURRENCY:
              print("Maximum concurrency reached, no new approvals will be made")
              exit(0)

          # Get waiting deployments for test environment
          print("Fetching deployments...")
          deployments = make_request("deployments?environment=test&status=waiting")
          if not deployments:
              print("Failed to fetch deployments")
              exit(1)

          # Sort deployments by creation date (oldest first)
          print("Sorting deployments...")
          sorted_deployments = sorted(deployments, key=lambda x: x["created_at"])

          # Process each deployment
          print("Processing deployments...")
          for deployment in sorted_deployments:
              if deployment["task"] != "cicd-wait-in-queue":
                  continue

              if total_workflows >= MAX_CONCURRENCY:
                  print("Maximum concurrency reached, stopping approvals")
                  break

              # Get PR information
              print(f"Fetching PR information for deployment {deployment['id']}...")
              prs = make_request("pulls?state=open")
              pr_info = "No PR found"

              if prs:
                  for pr in prs:
                      if pr["head"]["sha"] == deployment["sha"]:
                          pr_info = f"PR #{pr['number']}: {pr['title']}"
                          break

              print(f"Approving deployment {deployment['id']} (created at {deployment['created_at']}) - {pr_info}")

              # Approve the deployment
              status_data = {
                  "state": "success",
                  "description": "Automatically approved by queue manager"
              }
              result = make_request(f"deployments/{deployment['id']}/statuses", method="POST", data=status_data)

              if result:
                  total_workflows += 1
              else:
                  print(f"Failed to approve deployment {deployment['id']}")
          EOF

