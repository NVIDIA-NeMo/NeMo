import os
import string
from argparse import ArgumentParser
from typing import List

import pynini
from pynini import Far

from nemo.utils import logging


"""
This files takes 1. FST path 2. entire string 3. start position of substring 4. end (exclusive) position of substring
and returns 1. mapped output string 2. start and end indices of mapped substring

Usage: 

python alignment.py <fst file> \"2615 Forest Av, 1 Aug 2016\" 22 26

Output:
inp string: |2615 Forest Av, 1 Aug 2016|
out string: |twenty six fifteen Forest Avenue , the first of august twenty sixteen|
inp indices: [22:26]
out indices: [55:69]
in: |2016| out: |twenty sixteen|
"""


def parse_args():
    args = ArgumentParser("map substring to output with FST")
    args.add_argument("fst", help="FAR file containing FST", type=str)
    args.add_argument("--text", help="input string", type=str, default="2615 Forest Av, 1 Aug 2016")
    args.add_argument("--start", help="start index of substring to be mapped", type=int, default=22)
    args.add_argument("--end", help="end index of substring to be mapped", type=int, default=26)
    return args.parse_args()


EPS = "<eps>"
WHITE_SPACE = "\u23B5"


def create_symbol_table() -> pynini.SymbolTable:
    """
    Creates and returns Pynini SymbolTable used to label alignment with ascii instead of integers
    """
    table = pynini.SymbolTable()
    for num in range(34, 200):
        table.add_symbol(chr(num), num)
    table.add_symbol(EPS, 0)
    table.add_symbol(WHITE_SPACE, 32)
    return table


def get_string_alignment(fst: pynini.Fst, input_text: str, symbol_table: pynini.SymbolTable):
    """
    create alignment of input text based on shortest path in FST. Symbols used for alignment are from symbol_table

    Returns:
        output: list of tuples, each mapping input character to output
    """
    lattice = pynini.shortestpath(input_text @ fst)
    paths = lattice.paths(input_token_type=symbol_table, output_token_type=symbol_table)

    ilabels = paths.ilabels()
    olabels = paths.olabels()
    # print(paths.istring())
    # print(paths.ostring())
    output = list(zip([symbol_table.find(x) for x in ilabels], [symbol_table.find(x) for x in olabels]))
    paths.next()
    assert paths.done()
    output_str = "".join(map(remove, [x[1] for x in output]))
    return output, output_str


def _get_aligned_index(alignment: List[tuple], index: int):
    """
    Given index in contracted input string computes corresponding index in alignment (which has EPS)
    """
    aligned_index = 0
    idx = 0

    while idx < index:
        if alignment[aligned_index][0] != EPS:
            idx += 1
        aligned_index += 1
    while alignment[aligned_index][0] == EPS:
        aligned_index += 1
    return aligned_index


def _get_original_index(alignment, aligned_index):
    """
    Given index in aligned output, returns corresponding index in contracted output string
    """

    og_index = 0
    idx = 0
    while idx < aligned_index:
        if alignment[idx][1] != EPS:
            og_index += 1
        idx += 1
    return og_index


remove = lambda x: "" if x == EPS else " " if x == WHITE_SPACE else x


def indexed_map_to_output(alignment: List[tuple], start: int, end: int):
    """
    Given input start and end index of contracted substring return corresponding output start and end index

    Args:
        alignment: alignment generated by FST with shortestpath, is longer than original string since including eps transitions
        start: inclusive start position in input string
        end: exclusive end position in input string

    Returns:
        output_og_start_index: inclusive start position in output string
        output_og_end_index: exclusive end position in output string
    """
    # get aligned start and end of input substring
    aligned_start = _get_aligned_index(alignment, start)
    aligned_end = _get_aligned_index(alignment, end - 1)  # inclusive

    logging.debug(f"0: |{list(map(remove, [x[0] for x in alignment[aligned_start:aligned_end+1]]))}|")

    # extend aligned_start to left
    while (
        aligned_start - 1 > 0
        and alignment[aligned_start - 1][0] == EPS
        and (alignment[aligned_start - 1][1].isalpha() or alignment[aligned_start - 1][1] == EPS)
    ):
        aligned_start -= 1

    while (
        aligned_end + 1 < len(alignment)
        and alignment[aligned_end + 1][0] == EPS
        and (alignment[aligned_end + 1][1].isalpha() or alignment[aligned_end + 1][1] == EPS)
    ):
        aligned_end += 1

    while (aligned_end + 1) < len(alignment) and (
        alignment[aligned_end + 1][1].isalpha() or alignment[aligned_end + 1][1] == EPS
    ):
        aligned_end += 1

    output_og_start_index = _get_original_index(alignment=alignment, aligned_index=aligned_start)
    output_og_end_index = _get_original_index(alignment=alignment, aligned_index=aligned_end + 1)
    return output_og_start_index, output_og_end_index


if __name__ == '__main__':
    logging.setLevel(logging.INFO)
    args = parse_args()
    fst = Far(args.fst, mode='r')['tokenize_and_classify']
    input_text = args.text

    table = create_symbol_table()
    alignment, output_text = get_string_alignment(fst=fst, input_text=input_text, symbol_table=table)
    start, end = indexed_map_to_output(start=args.start, end=args.end, alignment=alignment)
    print(f"inp string: |{args.text}|")
    print(f"out string: |{output_text}|")
    print(f"inp indices: [{args.start}:{args.end}]")
    print(f"out indices: [{start}:{end}]")
    print(f"in: |{input_text[args.start:args.end]}| out: |{output_text[start:end]}|")
